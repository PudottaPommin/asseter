package asseter

import (
	"bytes"
	"crypto/sha256"
	"fmt"
	"go/format"
	"io"
	"io/fs"
	"log"
	"os"
	"path"
	"path/filepath"
	"text/template"
	"time"

	"github.com/klauspost/compress/zstd"
	"github.com/valyala/bytebufferpool"
)

type (
	AssetsFsOptions struct {
		Cwd string
		Src string
		Pkg string
		Out string
	}
	AssetsFsHandler struct {
		cwd string
		src string
		pkg string
		out string
	}
	file struct {
		Path             string
		Name             string
		Hash             string
		ModTime          time.Time
		UncompressedSize int
		CompressedData   []byte
		UncompressedData []byte
	}
	direntry struct {
		Name  string
		IsDir bool
	}
	assetsFsTemplateModel struct {
		Pkg   string
		Files []file
		Dirs  map[string][]direntry
	}
)

func NewAssetsFsHandler(o AssetsFsOptions) (*AssetsFsHandler, error) {
	return &AssetsFsHandler{
		cwd: o.Cwd,
		src: o.Src,
		pkg: o.Pkg,
		out: o.Out,
	}, nil
}

func (h *AssetsFsHandler) Run() error {
	root, err := os.OpenRoot(filepath.Clean(filepath.Join(h.cwd, h.src)))
	if err != nil {
		log.Fatalln(err)
	}
	defer root.Close()
	rfs := root.FS()

	enc, err := zstd.NewWriter(nil, zstd.WithEncoderLevel(zstd.SpeedBestCompression))
	if err != nil {
		return err
	}
	defer enc.Close()

	files := make([]file, 0)
	dirs := make(map[string][]direntry)

	if err = fs.WalkDir(rfs, ".", func(fp string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			entries, err := fs.ReadDir(rfs, fp)
			if err != nil {
				return err
			}
			dirEntries := make([]direntry, 0, len(entries))
			for i := range entries {
				dirEntries = append(dirEntries, direntry{Name: entries[i].Name(), IsDir: entries[i].IsDir()})
			}
			dirs[fp] = dirEntries
			return nil
		}

		src, err := fs.ReadFile(rfs, fp)
		if err != nil {
			return err
		}

		fi, err := d.Info()
		if err != nil {
			return err
		}

		dst := enc.EncodeAll(src, nil)
		if len(dst) < len(src) {
			files = append(files, file{
				Path:             fp,
				Name:             path.Base(fp),
				Hash:             hashBytes(src),
				ModTime:          fi.ModTime(),
				UncompressedSize: len(src),
				CompressedData:   dst,
			})
		} else {
			files = append(files, file{
				Path:             fp,
				Name:             path.Base(fp),
				Hash:             hashBytes(src),
				ModTime:          fi.ModTime(),
				UncompressedData: src,
			})
		}
		return nil
	}); err != nil {
		return err
	}

	out, err := os.OpenFile(h.out, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0o644)
	if err != nil {
		return err
	}
	defer out.Close()

	buffer := bytebufferpool.Get()
	defer buffer.Reset()
	if err = tmpl.ExecuteTemplate(out, "assetsfs.gotmpl", assetsFsTemplateModel{
		Pkg:   h.pkg,
		Files: files,
		Dirs:  dirs,
	}); err != nil {
		return fmt.Errorf("failed render outfile.go: %w", err)
	}

	var formatted []byte
	if formatted, err = format.Source(buffer.Bytes()); err != nil {
		return fmt.Errorf("failed format bindata.asseter.go: %w", err)
	}

	if _, err = io.Copy(out, bytes.NewReader(formatted)); err != nil {
		return fmt.Errorf("failed write bindata.asseter.go: %w", err)
	}

	return nil
}

func hashBytes(b []byte) string {
	return fmt.Sprintf("%x", sha256.Sum256(b))
}

func (f file) HashedName() string {
	if f.Hash == "" {
		return f.Name
	}
	ext := filepath.Ext(f.Path)
	pured := f.Path[:len(f.Path)-len(ext)]
	return fmt.Sprintf("%s.%s%s", pured, f.Hash, ext)
}

var tmpl = template.Must(template.New("").Parse(`
{{define "assetsfs.gotmpl"}}
{{- /*gotype: github.com/pudottapommin/asseter.assetsFsTemplateModel*/ -}}
// Code generated by github.com/pudottapommin/asseter; DO NOT EDIT.
//go:build bindata
package {{.Pkg}}

import (
    "bytes"
    "io"
    "io/fs"
    "time"

    "github.com/klauspost/compress/zstd"
)

type normalBlob struct {
    name string
    mtime time.Time
    data []byte
}

type compressedBlob struct {
    name string
    mtime time.Time
    uncompressedSize int64
    data []byte
}

var (
    hashesMap = map[string][2]string{
    {{- range .Files}}
        "{{.Path}}": {"{{.HashedName}}", "{{.Hash}}"},
    {{- end}}
    }

    dirs = map[string][]fs.DirEntry{
    {{- range $k, $e := .Dirs}}
        "{{$k}}": {
        {{- range $e}}
            direntry{"{{.Name}}", {{.IsDir}}},
        {{- end}}
        },
    {{- end}}
    }

    files = map[string]any {
    {{- range .Files}}
        "{{.Path}}": {{- if .CompressedData -}}
            compressedBlob{"{{.Name}}", time.Unix({{.ModTime.Unix}}, 0), {{.UncompressedSize}}, []byte({{printf "%+q" .CompressedData}})},
        {{- else -}}
            normalBlob{"{{.Name}}", time.Unix({{.ModTime.Unix}}, 0), []byte({{printf "%+q" .UncompressedData}})},
        {{- end -}}
    {{- end}}
    }
)

type assets struct {}
var Assets = assets{}

func (a assets) Open(name string) (fs.File, error) {
    for k, v := range hashesMap {
        if name == v[0] {
            name = k
            break
        }
    }

    f, ok := files[name]
    if !ok {
        return nil, &fs.PathError{Op: "open", Path: name, Err: fs.ErrNotExist}
    }
    hm := hashesMap[name]
    switch f := f.(type) {
    case normalBlob:
        return file{name: f.name, hashedName: hm[0], hash: hm[1], mtime: f.mtime, size: int64(len(f.data)), data: bytes.NewReader(f.data)}, nil
    case compressedBlob:
        r, _ := zstd.NewReader(bytes.NewReader(f.data))
        return &compressedFile{name: f.name, hashedName: hm[0], hash: hm[1], mtime: f.mtime, size: f.uncompressedSize, decoder: r, data: f.data}, nil
    default:
        panic("unreachable")
    }
}

func (a assets) ReadDir(name string) ([]fs.DirEntry, error) {
    if d, ok := dirs[name]; ok {
        return d, nil
    }
    return nil, &fs.PathError{Op: "readdir", Path: name, Err: fs.ErrNotExist}
}

func (a assets) HashedByPath(name string) string {
    if h, ok := hashesMap[name]; ok {
        return h[0]
    }
    return name
}

type file struct {
    name string
    hashedName string
    hash string
    mtime time.Time
    size int64
    data io.ReadSeeker
}

var _ io.ReadSeeker = (*file)(nil)

func (f file) Stat() (fs.FileInfo, error) {
    return fileinfo{name: f.name, size: f.size}, nil
}

func (f file) Read(p []byte) (int, error) {
    return f.data.Read(p)
}

func (f file) Seek(offset int64, whence int) (int64, error) {
    return f.data.Seek(offset, whence)
}

func (f file) Close() error { return nil }

func (f file) HashedName() string { return f.hashedName }
func (f file) Hash() string { return f.hash }

type compressedFile struct {
    name string
    hashedName string
    hash string
    mtime time.Time
    size int64
    decoder *zstd.Decoder
    data []byte
    zstdPos int64
    seekPos int64
}

var _ io.ReadSeeker = (*compressedFile)(nil)

func (f *compressedFile) Stat() (fs.FileInfo, error) {
    return fileinfo{name: f.name, size: f.size}, nil
}

func (f *compressedFile) Read(p []byte) (int, error) {
    if f.zstdPos > f.seekPos {
        if err := f.decoder.Reset(bytes.NewReader(f.data)); err != nil {
            return 0, err
        }
        f.zstdPos = 0
    }
    if f.zstdPos < f.seekPos {
        if _, err := io.CopyN(io.Discard, f.decoder, f.seekPos - f.zstdPos); err != nil {
            return 0, err
        }
        f.zstdPos = f.seekPos
    }
    n, err := f.decoder.Read(p)
    f.zstdPos += int64(n)
    f.seekPos = f.zstdPos
    return n, err
}

func (f *compressedFile) Seek(offset int64, whence int) (int64, error) {
    switch whence {
        case io.SeekStart:
            f.seekPos = 0 + offset
        case io.SeekCurrent:
            f.seekPos += offset
        case io.SeekEnd:
            f.seekPos = f.size + offset
    }
    return f.seekPos, nil
}

func (f *compressedFile) Close() error {
    f.decoder.Close()
    return nil
}

func (f *compressedFile) HashedName() string { return f.hashedName }
func (f *compressedFile) Hash() string { return f.hash }

func (f *compressedFile) ZstdBytes() []byte { return f.data }

type fileinfo struct {
    name string
    size int64
    mtime time.Time
}

func (f fileinfo) Name() string       { return f.name }
func (f fileinfo) Size() int64        { return f.size }
func (f fileinfo) Mode() fs.FileMode  { return 0o444 }
func (f fileinfo) ModTime() time.Time { return f.mtime }
func (f fileinfo) IsDir() bool        { return false }
func (f fileinfo) Sys() any           { return nil }

type direntry struct {
    name string
    isDir bool
}
func (d direntry) Name() string { return d.name }
func (d direntry) IsDir() bool  { return d.isDir }
func (d direntry) Type() fs.FileMode {
    if d.isDir {
        return 0o755 | fs.ModeDir
    }
    return 0o444
}
func (direntry) Info() (fs.FileInfo, error) { return nil, fs.ErrNotExist }
{{end}}
`))

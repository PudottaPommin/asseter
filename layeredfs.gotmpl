{{define "assetsfs.gotmpl"}}
{{- /*gotype: github.com/pudottapommin/asseter.assetsFsTemplateModel*/ -}}
// Code generated by github.com/pudottapommin/asseter; DO NOT EDIT.
//go:build bindata
package {{.Pkg}}

import (
    "bytes"
    "io"
    "io/fs"
    "time"

    "github.com/klauspost/compress/zstd"
)

type normalBlob struct {
    name string
    mtime time.Time
    data []byte
}

type compressedBlob struct {
    name string
    mtime time.Time
    uncompressedSize int64
    data []byte
}

var (
    hashesMap = map[string][2]string{
    {{- range .Files}}
        "{{.Path}}": {"{{.HashedName}}", "{{.Hash}}"},
    {{- end}}
    }

    dirs = map[string][]fs.DirEntry{
    {{- range $k, $e := .Dirs}}
        "{{$k}}": {
        {{- range $e}}
            direntry{"{{.Name}}", {{.IsDir}}},
        {{- end}}
        },
    {{- end}}
    }

    files = map[string]any {
    {{- range .Files}}
        "{{.Path}}": {{- if .CompressedData -}}
            compressedBlob{"{{.Name}}", time.Unix({{.ModTime.Unix}}, 0), {{.UncompressedSize}}, []byte({{printf "%+q" .CompressedData}})},
        {{- else -}}
            normalBlob{"{{.Name}}", time.Unix({{.ModTime.Unix}}, 0), []byte({{printf "%+q" .UncompressedData}})},
        {{- end -}}
    {{- end}}
    }
)

type assets struct {}
var Assets = assets{}

func (a assets) Open(name string) (fs.File, error) {
    for k, v := range hashesMap {
        if name == v[0] {
            name = k
            break
        }
    }

    f, ok := files[name]
    if !ok {
        return nil, &fs.PathError{Op: "open", Path: name, Err: fs.ErrNotExist}
    }
    hm := hashesMap[name]
    switch f := f.(type) {
    case normalBlob:
        return file{name: f.name, hashedName: hm[0], hash: hm[1], mtime: f.mtime, size: int64(len(f.data)), data: bytes.NewReader(f.data)}, nil
    case compressedBlob:
        r, _ := zstd.NewReader(bytes.NewReader(f.data))
        return &compressedFile{name: f.name, hashedName: hm[0], hash: hm[1], mtime: f.mtime, size: f.uncompressedSize, decoder: r, data: f.data}, nil
    default:
        panic("unreachable")
    }
}

func (a assets) ReadDir(name string) ([]fs.DirEntry, error) {
    if d, ok := dirs[name]; ok {
        return d, nil
    }
    return nil, &fs.PathError{Op: "readdir", Path: name, Err: fs.ErrNotExist}
}

func (a assets) HashedByPath(name string) string {
    if h, ok := hashesMap[name]; ok {
        return h[0]
    }
    return name
}

type file struct {
    name string
    hashedName string
    hash string
    mtime time.Time
    size int64
    data io.ReadSeeker
}

var _ io.ReadSeeker = (*file)(nil)

func (f file) Stat() (fs.FileInfo, error) {
    return fileinfo{name: f.name, size: f.size}, nil
}

func (f file) Read(p []byte) (int, error) {
    return f.data.Read(p)
}

func (f file) Seek(offset int64, whence int) (int64, error) {
    return f.data.Seek(offset, whence)
}

func (f file) Close() error { return nil }

func (f file) HashedName() string { return f.hashedName }
func (f file) Hash() string { return f.hash }

type compressedFile struct {
    name string
    hashedName string
    hash string
    mtime time.Time
    size int64
    decoder *zstd.Decoder
    data []byte
    zstdPos int64
    seekPos int64
}

var _ io.ReadSeeker = (*compressedFile)(nil)

func (f *compressedFile) Stat() (fs.FileInfo, error) {
    return fileinfo{name: f.name, size: f.size}, nil
}

func (f *compressedFile) Read(p []byte) (int, error) {
    if f.zstdPos > f.seekPos {
        if err := f.decoder.Reset(bytes.NewReader(f.data)); err != nil {
            return 0, err
        }
        f.zstdPos = 0
    }
    if f.zstdPos < f.seekPos {
        if _, err := io.CopyN(io.Discard, f.decoder, f.seekPos - f.zstdPos); err != nil {
            return 0, err
        }
        f.zstdPos = f.seekPos
    }
    n, err := f.decoder.Read(p)
    f.zstdPos += int64(n)
    f.seekPos = f.zstdPos
    return n, err
}

func (f *compressedFile) Seek(offset int64, whence int) (int64, error) {
    switch whence {
        case io.SeekStart:
            f.seekPos = 0 + offset
        case io.SeekCurrent:
            f.seekPos += offset
        case io.SeekEnd:
            f.seekPos = f.size + offset
    }
    return f.seekPos, nil
}

func (f *compressedFile) Close() error {
    f.decoder.Close()
    return nil
}

func (f *compressedFile) HashedName() string { return f.hashedName }
func (f *compressedFile) Hash() string { return f.hash }

func (f *compressedFile) ZstdBytes() []byte { return f.data }

type fileinfo struct {
    name string
    size int64
    mtime time.Time
}

func (f fileinfo) Name() string       { return f.name }
func (f fileinfo) Size() int64        { return f.size }
func (f fileinfo) Mode() fs.FileMode  { return 0o444 }
func (f fileinfo) ModTime() time.Time { return f.mtime }
func (f fileinfo) IsDir() bool        { return false }
func (f fileinfo) Sys() any           { return nil }

type direntry struct {
    name string
    isDir bool
}
func (d direntry) Name() string { return d.name }
func (d direntry) IsDir() bool  { return d.isDir }
func (d direntry) Type() fs.FileMode {
    if d.isDir {
        return 0o755 | fs.ModeDir
    }
    return 0o444
}
func (direntry) Info() (fs.FileInfo, error) { return nil, fs.ErrNotExist }
{{end}}